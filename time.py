"""Prototype script to analyze temporal information from the data generated by 
   the tracking algorithm. Calculates various statistics related to flow rate 
   over time."

Connor Coward
19 June 2018
"""

from mpl_toolkits.mplot3d import Axes3D
import numpy as np
import numpy.random
import random 
import matplotlib.pyplot as plt
import csv
import sys
import math
import random

# Search radius for finding center of data
RADIUS = 1

def getCentroid(arr):
	"""Calculates the centroid of a 2d array where each row is a 3d point"""
    length = arr.shape[0]
    sum_x = np.sum(arr[:, 1]) 
    sum_y = np.sum(arr[:, 2])
    return np.array([sum_x/length, sum_y/length])

# Basic user input sanity checking
if len(sys.argv) != 2:
    print "USAGE: ", sys.argv[0] + " filename"
    exit(-1)

# Grab csv input file
inputFileName = sys.argv[1]
rawFile = open(inputFileName, 'rb')
csvReader = csv.reader(rawFile, delimiter = ',')

# Load all data from the file into a list
points = np.array(
	[np.array([float(item) for item in row]) for row in csvReader])

# Find the center using a RANSAC algorithm
bestSeed = points[0]

bestCount = sum(
	[1 for p in points if np.linalg.norm(p[1:] - points[0][1:]) < RADIUS])

bestInliers = np.array(
	[p for p in points[1:] if np.linalg.norm(p[1:] - points[0][1:]) < RADIUS])

for x in xrange(0, 50):
    seed = random.choice(points[1:])[1:]
    inliers = np.array(
		[p for p in points[1:] if np.linalg.norm(p[1:] - seed) < RADIUS])
    if len(inliers) > bestCount:
        bestCount = len(inliers)
        bestSeed = seed
        bestInliers = inliers

print "bestSeed:", bestSeed
print "bestCount:", bestCount

radius = RADIUS
inliers = bestInliers
while len(inliers) < 0.5 * len(points):
    centroid = getCentroid(inliers)
    inliers = np.array(
		[p for p in points[1:] if np.linalg.norm(p[1:] - centroid) < radius])
    radius = radius * 1.02

print "numInliers: ", len(inliers)
print "radius: ", radius
print "total particle count: ", len(points)

# Spatial filter by hypothetical meltpool diameter
filtered = np.array(
	[p for p in points if np.linalg.norm(p[1:] - centroid) < 2])[:,0]
filtered = np.sort(filtered)
print "max(filtered): ", max(filtered)
print "len(filtered): ", len(filtered)
print "material efficiency: %", 100.0 * float(len(filtered)) / len(points)

# Add up particles within a time 'window'. The window represents a window of
#     time in which particles that hit the substrate would have struck
#     a meltpool had it been an actual deposit. This calcualtes a hypothetical
#     material input rate to a meltpool over time.
window = int((4.0 / (600.0 / 60)) * 4500)
print "window: ", window
sim = []
ts = []
for f in filtered:
	if f >= window:
		ts.append(f)
		sim.append(sum([1 for _f in filtered if _f < f and _f > f - window]))

print "mean: ", np.mean(sim)
print "standard deviation: ", np.std(sim)
print "standard deviation: %", 100*np.std(sim)/np.mean(sim)

# Create plots
ax = plt.subplot(111)
ax.plot(ts, sim)
ax.set_xlim([window, max(filtered)])
ax.set_ylim([0, max(sim)*1.1])
plt.show()

# Save hypothetical material input rate over time to CSV
with open('time.csv', 'w') as f:
	for t, s in zip(ts, sim):
		f.write(str(t) + ',' + str(s) + '\n')

